/*
 * Copyright (c) Lightbend Inc. 2021
 *
 */

package com.lightbend.akkasls.codegen
package java

import com.google.common.base.Charsets
import org.bitbucket.inkytonik.kiama.output.PrettyPrinter
import org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Document

import _root_.java.nio.file.{ Files, Path, Paths }

/**
  * Responsible for generating Java source from an entity model
  */
object SourceGenerator extends PrettyPrinter {

  /**
    * Generate Java source from entities where the target source and test source directories have no existing source.
    * Note that we only generate tests for entities where we are successful in generating an entity. The user may
    * not want a test otherwise.
    *
    * Also generates a main source file if it does not already exist.
    *
    * Impure.
    *
    * @param model The model of entity metadata to generate source file
    * @param sourceDirectory A directory to generate source files in, which can also containing existing source.
    * @param testSourceDirectory A directory to generate test source files in, which can also containing existing source.
    * @param integrationTestSourceDirectory A directory to generate integration test source files in, which can also containing existing source.
    * @param mainClass  A fully qualified classname to be used as the main class
    * @return A collection of paths addressing source files generated by this function
    */
  def generate(
      model: ModelBuilder.Model,
      sourceDirectory: Path,
      testSourceDirectory: Path,
      integrationTestSourceDirectory: Path,
      generatedSourceDirectory: Path,
      mainClass: String
  ): Iterable[Path] = {

    val (mainClassPackageName, mainClassName) = disassembleClassName(mainClass)

    model.services.values.flatMap {
      case service: ModelBuilder.EntityService =>
        model.entities
          .get(service.componentFullName)
          .toSeq
          .flatMap(entity =>
            EntityServiceSourceGenerator.generate(
              entity,
              service,
              sourceDirectory,
              testSourceDirectory,
              integrationTestSourceDirectory,
              generatedSourceDirectory,
              mainClassPackageName,
              mainClassName
            )
          )
      case service: ModelBuilder.ViewService if service.transformedUpdates.nonEmpty =>
        ViewServiceSourceGenerator.generate(
          service,
          sourceDirectory,
          testSourceDirectory,
          integrationTestSourceDirectory,
          generatedSourceDirectory,
          mainClassPackageName,
          mainClassName
        )
      case service: ModelBuilder.ActionService =>
        ActionServiceSourceGenerator.generate(
          service,
          sourceDirectory,
          testSourceDirectory,
          integrationTestSourceDirectory,
          generatedSourceDirectory,
          mainClassPackageName,
          mainClassName
        )
      case _ => Seq.empty
    } ++ {
      val mainClassPackagePath = packageAsPath(mainClassPackageName)

      val mainComponentRegistrationsClassName = mainClassName + "ComponentRegistrations"
      val mainComponentRegistrationsSourcePath =
        generatedSourceDirectory.resolve(
          mainClassPackagePath.resolve(mainComponentRegistrationsClassName + ".java")
        )

      val _ = mainComponentRegistrationsSourcePath.getParent.toFile.mkdirs()
      val _ = Files.write(
        mainComponentRegistrationsSourcePath,
        mainComponentRegistrationsSource(mainClassPackageName, mainClassName, model).layout
          .getBytes(
            Charsets.UTF_8
          )
      )

      // Generate a main source file if it is not there already

      val mainClassPath =
        sourceDirectory.resolve(mainClassPackagePath.resolve(mainClassName + ".java"))
      if (!mainClassPath.toFile.exists()) {
        val _ = mainClassPath.getParent.toFile.mkdirs()
        val _ = Files.write(
          mainClassPath,
          mainSource(mainClassPackageName, mainClassName).layout
            .getBytes(
              Charsets.UTF_8
            )
        )
        List(mainComponentRegistrationsSourcePath, mainClassPath)
      } else {
        List.empty
      }
    }
  }

  private[codegen] def mainComponentRegistrationsSource(
      mainClassPackageName: String,
      mainClassName: String,
      model: ModelBuilder.Model
  ): Document = {
    val serviceRegistrations = model.services.values.flatMap {
      case service: ModelBuilder.EntityService =>
        model.entities.get(service.componentFullName).toSeq.map { entity: ModelBuilder.Entity =>
          (
            FullyQualifiedName(s"${entity.fqn.name}Impl", entity.fqn.parent),
            entity match {
              case _: ModelBuilder.EventSourcedEntity =>
                "registerEventSourcedEntity"
              case _: ModelBuilder.ValueEntity =>
                "registerValueEntity"
            },
            Seq(
              s"${entity.fqn.name}Impl" <> ".class",
              service.fqn.parent.javaOuterClassname <> ".getDescriptor().findServiceByName" <> parens(
                dquotes(service.fqn.name)
              )
            ),
            service.fqn.parent,
            (entity match {
              case ModelBuilder.EventSourcedEntity(fqn, _, state, events) =>
                events.map(_.fqn) ++ state.map(_.fqn)
              case ModelBuilder.ValueEntity(fqn, _, state) =>
                Seq(state.fqn)
            }) ++ service.commands.flatMap(command => Seq(command.inputType, command.outputType))
          )
        }
      case service: ModelBuilder.ViewService =>
        Some(
          (
            FullyQualifiedName(s"${service.fqn.name}Impl", service.fqn.parent),
            "registerView",
            (if (service.transformedUpdates.nonEmpty) {
               Seq(s"${service.fqn.name}Impl" <> ".class")
             } else Seq.empty) ++ Seq(
              service.fqn.parent.javaOuterClassname <> ".getDescriptor().findServiceByName" <> parens(
                dquotes(service.fqn.name)
              ),
              dquotes(service.viewId)
            ),
            service.fqn.parent,
            service.commands.flatMap(command => Seq(command.inputType, command.outputType))
          )
        )
      case service: ModelBuilder.ActionService =>
        Some(
          (
            FullyQualifiedName(s"${service.fqn.name}Impl", service.fqn.parent),
            "registerAction",
            Seq(
              s"${service.fqn.name}Impl" <> ".class",
              service.fqn.parent.javaOuterClassname <> ".getDescriptor().findServiceByName" <> parens(
                dquotes(service.fqn.name)
              )
            ),
            service.fqn.parent,
            service.commands.flatMap(command => Seq(command.inputType, command.outputType))
          )
        )
      case _ => None
    }

    val imports = (List(
      "com.akkaserverless.javasdk.AkkaServerless"
    ) ++
      serviceRegistrations
        .flatMap { case (implType, _, _, _, relevantTypes) =>
          Seq(implType.name -> implType.parent.javaPackage) ++ relevantTypes.map {
            case FullyQualifiedName(_, parent) =>
              parent.javaOuterClassname -> parent.javaPackage
          }
        }
        .collect {
          case (name, pn) if pn != mainClassPackageName =>
            s"$pn.$name"
        }).distinct.sorted

    pretty(
      "package" <+> mainClassPackageName <> semi <> line <>
      line <>
      ssep(
        imports.map(pkg => "import" <+> pkg <> semi),
        line
      ) <> line <>
      line <>
      `class`("public" <+> "final", mainClassName + "ComponentRegistrations") {
        line <>
        method(
          "public" <+> "static",
          "AkkaServerless",
          "withGeneratedComponentsAdded",
          List("AkkaServerless" <+> "akkaServerless"),
          emptyDoc
        ) {
          "return" <+> "akkaServerless" <> line <>
          indent(
            ssep(
              serviceRegistrations.map {
                case (implType, registrationMethod, args, serviceDescriptor, relevantTypes) =>
                  dot <>
                    registrationMethod <> parens(
                      nest(
                        line <> ssep(
                          args ++ relevantTypes
                            .map(_.parent)
                            .toSeq
                            .distinct
                            .filterNot(_ == serviceDescriptor)
                            .map { descriptor =>
                              descriptor.javaOuterClassname <> ".getDescriptor()"
                            },
                          comma <> line
                        )
                      ) <> line
                    )
              }.toSeq,
              line
            ) <> semi,
            8
          )
        }
      }
    )
  }

  private[codegen] def mainSource(
      mainClassPackageName: String,
      mainClassName: String
  ): Document = {

    val imports = List(
      "import" <+> "com.akkaserverless.javasdk.AkkaServerless" <> semi <> line <>
      "import" <+> "org.slf4j.Logger" <> semi <> line <>
      "import" <+> "org.slf4j.LoggerFactory" <> semi
    )

    pretty(
      "package" <+> mainClassPackageName <> semi <> line <>
      line <>
      ssep(
        imports,
        line
      ) <> line <>
      line <>
      "import" <+> "static" <+> mainClassPackageName <> dot <> (mainClassName + "ComponentRegistrations") <> dot <> "withGeneratedComponentsAdded" <> semi <> line <>
      line <>
      `class`("public" <+> "final", mainClassName) {
        line <>
        field(
          "private" <+> "static" <+> "final",
          "Logger",
          "LOG",
          assignmentSeparator = Some(" ")
        )("LoggerFactory.getLogger" <> parens("Main.class") <> semi) <> linebreak <>
        line <>
        method(
          "public" <+> "static",
          "void",
          "main",
          List("String[]" <+> "args"),
          "throws" <+> "Exception" <> space
        ) {
          "LOG.info" <> parens("\"starting the Akka Serverless service\"") <> semi <> line <>
          "withGeneratedComponentsAdded" <> parens(
            "new" <+> "AkkaServerless" <> parens(
              emptyDoc
            )
          ) <> line <>
          indent(".start().toCompletableFuture().get()", 8) <> semi
        }
      }
    )
  }

  private def disassembleClassName(fullClassName: String): (String, String) = {
    val className   = fullClassName.reverse.takeWhile(_ != '.').reverse
    val packageName = fullClassName.dropRight(className.length + 1)
    packageName -> className
  }

  private[java] def `class`(modifier: Doc, name: String)(body: Doc): Doc =
    `class`(modifier, name, None)(body)

  private[java] def `class`(modifier: Doc, name: String, extension: Option[String])(
      body: Doc
  ): Doc =
    modifier <+> "class" <+> name <+>
    extension.fold(emptyDoc)(ext => "extends" <+> ext <> space) <>
    braces(nest(line <> body) <> line)

  private[java] def constructor(
      modifier: Doc,
      name: String,
      parameters: Seq[Doc]
  )(body: Doc): Doc =
    modifier <+> name <> parens(ssep(parameters, comma <> space)) <+>
    braces(nest(line <> body) <> line)

  private[java] def method(
      modifier: Doc,
      returnType: Doc,
      name: String,
      parameters: Seq[Doc],
      postModifier: Doc
  )(body: Doc): Doc =
    modifier <+> returnType <+> name <> parens(ssep(parameters, comma <> space)) <+> postModifier <>
    braces(nest(line <> body) <> line)

  private[java] def field(
      modifier: Doc,
      fieldType: Doc,
      name: String,
      assignmentSeparator: Option[Doc]
  )(assignment: Doc): Doc =
    modifier <+> fieldType <+> name <> (assignmentSeparator match {
      case Some(separator) =>
        space <> equal <> separator <> nest(assignment)
      case None => emptyDoc
    })

  private[java] def abstractMethod(
      modifier: Doc,
      returnType: Doc,
      name: String,
      parameters: Seq[Doc]
  ): Doc =
    modifier <+> "abstract" <+> returnType <+> name <> parens(ssep(parameters, comma <> space))

  private[java] def qualifiedType(fullyQualifiedName: FullyQualifiedName): String =
    if (fullyQualifiedName.parent.javaMultipleFiles) fullyQualifiedName.name
    else s"${fullyQualifiedName.parent.javaOuterClassname}.${fullyQualifiedName.name}"

  private[java] def typeImport(fullyQualifiedName: FullyQualifiedName): String = {
    val name =
      if (fullyQualifiedName.parent.javaMultipleFiles) fullyQualifiedName.name
      else fullyQualifiedName.parent.javaOuterClassname
    s"${fullyQualifiedName.parent.javaPackage}.$name"
  }

  private[java] def lowerFirst(text: String): String =
    text.headOption match {
      case Some(c) => c.toLower.toString + text.drop(1)
      case None    => ""
    }

  private[java] def notImplementedError(handlerType: String, fqn: FullyQualifiedName) = dquotes(
    "The" <+> handlerType <+> "handler for `" <> fqn.name <> "` is not implemented, yet"
  )

  private[java] def packageAsPath(packageName: String): Path =
    Paths.get(packageName.replace(".", "/"))
}
