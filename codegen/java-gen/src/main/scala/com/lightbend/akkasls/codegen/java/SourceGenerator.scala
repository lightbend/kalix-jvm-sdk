/*
 * Copyright 2021 Lightbend Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.lightbend.akkasls.codegen
package java

import com.google.common.base.Charsets
import org.bitbucket.inkytonik.kiama.output.PrettyPrinter
import org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Document
import _root_.java.nio.file.{Files, Path, Paths}

import com.lightbend.akkasls.codegen.ModelBuilder.Command
import com.lightbend.akkasls.codegen.ModelBuilder.State

/**
 * Responsible for generating Java source from an entity model
 */
object SourceGenerator extends PrettyPrinter {

  /**
   * Generate Java source from entities where the target source and test source directories have no existing source.
   * Note that we only generate tests for entities where we are successful in generating an entity. The user may
   * not want a test otherwise.
   *
   * Also generates a main source file if it does not already exist.
   *
   * Impure.
   *
   * @param model The model of entity metadata to generate source file
   * @param sourceDirectory A directory to generate source files in, which can also containing existing source.
   * @param testSourceDirectory A directory to generate test source files in, which can also containing existing source.
   * @param integrationTestSourceDirectory A directory to generate integration test source files in, which can also containing existing source.
   * @param mainClass  A fully qualified classname to be used as the main class
   * @return A collection of paths addressing source files generated by this function
   */
  def generate(
      model: ModelBuilder.Model,
      sourceDirectory: Path,
      testSourceDirectory: Path,
      integrationTestSourceDirectory: Path,
      generatedSourceDirectory: Path,
      mainClass: String
  )(implicit log: Log): Iterable[Path] = {

    val (mainClassPackageName, mainClassName) = disassembleClassName(mainClass)

    model.services.values.flatMap {
      case service: ModelBuilder.EntityService =>
        model.entities.get(service.componentFullName) match {
          case None =>
            // TODO perhaps we even want to make this an error, to really go all-in on codegen?
            log.warning(
              "Service [" + service.fqn.fullName + "] refers to entity [" + service.componentFullName +
              "], but no entity configuration is found for that component name"
            )
            Seq.empty
          case Some(entity) =>
            EntityServiceSourceGenerator.generate(
              entity,
              service,
              sourceDirectory,
              testSourceDirectory,
              integrationTestSourceDirectory,
              generatedSourceDirectory,
              mainClassPackageName,
              mainClassName
            ) ++
            EventSourcedEntityTestKitGenerator.generate(
              entity,
              service,
              generatedSourceDirectory
            )

        }
      case service: ModelBuilder.ViewService if service.transformedUpdates.nonEmpty =>
        ViewServiceSourceGenerator.generate(
          service,
          sourceDirectory,
          testSourceDirectory,
          integrationTestSourceDirectory,
          generatedSourceDirectory,
          mainClassPackageName,
          mainClassName
        )
      case service: ModelBuilder.ActionService =>
        ActionServiceSourceGenerator.generate(
          service,
          sourceDirectory,
          testSourceDirectory,
          integrationTestSourceDirectory,
          generatedSourceDirectory,
          mainClassPackageName,
          mainClassName
        )
      case _ => Seq.empty
    } ++ {
      val mainClassPackagePath = packageAsPath(mainClassPackageName)

      val mainComponentRegistrationsClassName = mainClassName + "ComponentRegistrations"
      val mainComponentRegistrationsSourcePath =
        generatedSourceDirectory.resolve(
          mainClassPackagePath.resolve(mainComponentRegistrationsClassName + ".java")
        )

      val _ = mainComponentRegistrationsSourcePath.getParent.toFile.mkdirs()
      val _ = Files.write(
        mainComponentRegistrationsSourcePath,
        mainComponentRegistrationsSource(mainClassPackageName, mainClassName, model).layout
          .getBytes(
            Charsets.UTF_8
          )
      )

      // Generate a main source file if it is not there already

      val mainClassPath =
        sourceDirectory.resolve(mainClassPackagePath.resolve(mainClassName + ".java"))
      if (!mainClassPath.toFile.exists()) {
        val _ = mainClassPath.getParent.toFile.mkdirs()
        val _ = Files.write(
          mainClassPath,
          mainSource(mainClassPackageName, mainClassName).layout
            .getBytes(
              Charsets.UTF_8
            )
        )
        List(mainComponentRegistrationsSourcePath, mainClassPath)
      } else {
        List.empty
      }
    }
  }

  private[codegen] def mainComponentRegistrationsSource(
      mainClassPackageName: String,
      mainClassName: String,
      model: ModelBuilder.Model
  ): Document = {
    val serviceRegistrations = model.services.values.flatMap {
      case service: ModelBuilder.EntityService =>
        model.entities.get(service.componentFullName).toSeq.map { entity: ModelBuilder.Entity =>
          (
            FullyQualifiedName(s"${entity.fqn.name}", entity.fqn.parent),
            entity match {
              case _: ModelBuilder.EventSourcedEntity =>
                "registerEventSourcedEntity"
              case _: ModelBuilder.ValueEntity =>
                "registerValueEntity"
            },
            Seq(
              s"${entity.fqn.name}" <> ".class",
              service.fqn.parent.javaOuterClassname <> ".getDescriptor().findServiceByName" <> parens(
                dquotes(service.fqn.name)
              )
            ),
            service.fqn.parent,
            (entity match {
              case ModelBuilder.EventSourcedEntity(fqn, _, state, events) =>
                events.map(_.fqn) ++ state.map(_.fqn)
              case ModelBuilder.ValueEntity(fqn, _, state) =>
                Seq(state.fqn)
            }) ++ service.commands.flatMap(command => Seq(command.inputType, command.outputType))
          )
        }
      case service: ModelBuilder.ViewService =>
        Some(
          (
            FullyQualifiedName(s"${service.fqn.name}", service.fqn.parent),
            "registerView",
            (if (service.transformedUpdates.nonEmpty) {
               Seq(s"${service.fqn.name}" <> ".class")
             } else Seq.empty) ++ Seq(
              service.fqn.parent.javaOuterClassname <> ".getDescriptor().findServiceByName" <> parens(
                dquotes(service.fqn.name)
              ),
              dquotes(service.viewId)
            ),
            service.fqn.parent,
            service.commands.flatMap(command => Seq(command.inputType, command.outputType))
          )
        )
      case service: ModelBuilder.ActionService =>
        Some(
          (
            FullyQualifiedName(s"${service.fqn.name}", service.fqn.parent),
            "registerAction",
            Seq(
              s"${service.fqn.name}" <> ".class",
              service.fqn.parent.javaOuterClassname <> ".getDescriptor().findServiceByName" <> parens(
                dquotes(service.fqn.name)
              )
            ),
            service.fqn.parent,
            service.commands.flatMap(command => Seq(command.inputType, command.outputType))
          )
        )
      case _ => None
    }

    val imports = (List(
      "com.akkaserverless.javasdk.AkkaServerless"
    ) ++
    serviceRegistrations
      .flatMap {
        case (implType, _, _, _, relevantTypes) =>
          Seq(implType.name -> implType.parent.javaPackage) ++ relevantTypes.map {
            case FullyQualifiedName(_, parent) =>
              parent.javaOuterClassname -> parent.javaPackage
          }
      }
      .collect {
        case (name, pn) if pn != mainClassPackageName =>
          s"$pn.$name"
      }).distinct.sorted

    pretty(
      managedCodeComment <> line <> line <>
      "package" <+> mainClassPackageName <> semi <> line <>
      line <>
      ssep(
        imports.map(pkg => "import" <+> pkg <> semi),
        line
      ) <> line <>
      line <>
      `class`("public" <+> "final", mainClassName + "ComponentRegistrations") {
        line <>
        method(
          "public" <+> "static",
          "AkkaServerless",
          "withGeneratedComponentsAdded",
          List("AkkaServerless" <+> "akkaServerless"),
          emptyDoc
        ) {
          "return" <+> "akkaServerless" <> line <>
          indent(
            ssep(
              serviceRegistrations.map {
                case (implType, registrationMethod, args, serviceDescriptor, relevantTypes) =>
                  dot <>
                  registrationMethod <> parens(
                    nest(
                      line <> ssep(
                        args ++ relevantTypes
                          .map(_.parent)
                          .toSeq
                          .distinct
                          .filterNot(_ == serviceDescriptor)
                          .map { descriptor =>
                            descriptor.javaOuterClassname <> ".getDescriptor()"
                          },
                        comma <> line
                      )
                    ) <> line
                  )
              }.toSeq,
              line
            ) <> semi,
            8
          )
        }
      }
    )
  }

  private[codegen] def mainSource(
      mainClassPackageName: String,
      mainClassName: String
  ): Document = {

    val imports = List(
      "import" <+> "com.akkaserverless.javasdk.AkkaServerless" <> semi <> line <>
      "import" <+> "org.slf4j.Logger" <> semi <> line <>
      "import" <+> "org.slf4j.LoggerFactory" <> semi
    )

    pretty(
      initialisedCodeComment <> line <> line <>
      "package" <+> mainClassPackageName <> semi <> line <>
      line <>
      ssep(
        imports,
        line
      ) <> line <>
      line <>
      "import" <+> "static" <+> mainClassPackageName <> dot <> (mainClassName + "ComponentRegistrations") <> dot <> "withGeneratedComponentsAdded" <> semi <> line <>
      line <>
      `class`("public" <+> "final", mainClassName) {
        line <>
        field(
          "private" <+> "static" <+> "final",
          "Logger",
          "LOG",
          assignmentSeparator = Some(" ")
        )("LoggerFactory.getLogger" <> parens("Main.class") <> semi) <> line <>
        line <>
        field(
          "public" <+> "static" <+> "final",
          "AkkaServerless",
          "SERVICE",
          assignmentSeparator = Some(linebreak)
        )(
          indent(
            "// This withGeneratedComponentsAdded wrapper automatically registers any generated Actions, Views or Entities," <> line <>
            "// and is kept up-to-date with any changes in your protobuf definitions." <> line <>
            "// If you prefer, you may remove this wrapper and manually register these components." <> line <>
            "withGeneratedComponentsAdded" <> parens("new AkkaServerless()") <> semi,
            4
          )
        ) <> line <>
        line <>
        method(
          "public" <+> "static",
          "void",
          "main",
          List("String[]" <+> "args"),
          "throws" <+> "Exception" <> space
        ) {
          "LOG.info" <> parens("\"starting the Akka Serverless service\"") <> semi <> line <>
          "SERVICE.start()" <> semi
        }
      }
    )
  }

  private def disassembleClassName(fullClassName: String): (String, String) = {
    val className = fullClassName.reverse.takeWhile(_ != '.').reverse
    val packageName = fullClassName.dropRight(className.length + 1)
    packageName -> className
  }

  private[java] def `interface`(modifier: Doc, name: String)(body: Doc): Doc =
    modifier <+> "interface" <+> name <+>
    braces(nest(line <> body) <> line)

  private[java] def `class`(modifier: Doc, name: String)(body: Doc): Doc =
    `class`(modifier, name, None)(body)

  private[java] def `class`(modifier: Doc, name: String, extension: String)(body: Doc): Doc =
    `class`(modifier, name, Some(extension))(body)

  private[java] def `class`(modifier: Doc, name: String, extension: Option[String])(
      body: Doc
  ): Doc =
    modifier <+> "class" <+> name <+>
    extension.fold(emptyDoc)(ext => "extends" <+> ext <> space) <>
    braces(nest(line <> body) <> line)

  private[java] def constructor(
      modifier: Doc,
      name: String,
      parameters: Seq[Doc]
  )(body: Doc): Doc =
    modifier <+> name <> parens(ssep(parameters, comma <> space)) <+>
    braces(nest(line <> body) <> line)

  private[java] def method(
      modifier: Doc,
      returnType: Doc,
      name: String,
      parameters: Seq[Doc],
      postModifier: Doc
  )(body: Doc): Doc =
    modifier <+> returnType <+> name <> parens(ssep(parameters, comma <> space)) <+> postModifier <>
    braces(nest(line <> body) <> line)

  private[java] def field(
      modifier: Doc,
      fieldType: Doc,
      name: String,
      assignmentSeparator: Option[Doc]
  )(assignment: Doc): Doc =
    modifier <+> fieldType <+> name <> (assignmentSeparator match {
      case Some(separator) =>
        space <> equal <> separator <> nest(assignment)
      case None => emptyDoc
    })

  private[java] def abstractMethod(
      modifier: Doc,
      returnType: Doc,
      name: String,
      parameters: Seq[Doc]
  ): Doc =
    modifier <+> "abstract" <+> returnType <+> name <> parens(ssep(parameters, comma <> space))

  private[java] def qualifiedType(fullyQualifiedName: FullyQualifiedName): String =
    if (fullyQualifiedName.parent.javaMultipleFiles) fullyQualifiedName.name
    else s"${fullyQualifiedName.parent.javaOuterClassname}.${fullyQualifiedName.name}"

  private[java] def typeImport(fullyQualifiedName: FullyQualifiedName): String = {
    val name =
      if (fullyQualifiedName.parent.javaMultipleFiles) fullyQualifiedName.name
      else fullyQualifiedName.parent.javaOuterClassname
    s"${fullyQualifiedName.parent.javaPackage}.$name"
  }

  private[java] def lowerFirst(text: String): String =
    text.headOption match {
      case Some(c) => c.toLower.toString + text.drop(1)
      case None => ""
    }

  private[java] def notImplementedError(handlerType: String, fqn: FullyQualifiedName) = dquotes(
    "The" <+> handlerType <+> "handler for `" <> fqn.name <> "` is not implemented, yet"
  )

  private[java] def packageAsPath(packageName: String): Path =
    Paths.get(packageName.replace(".", "/"))

  private[java] val initialisedCodeComment: Doc =
    "/*" <+> "This code was initialised by Akka Serverless tooling." <> line <>
    " *" <+> "As long as this file exists it will not be re-generated." <> line <>
    " *" <+> "You are free to make changes to this file." <> line <>
    " */"

  private[java] val managedCodeComment: Doc =
    "/*" <+> "This code is managed by Akka Serverless tooling." <> line <>
    " *" <+> "It will be re-generated to reflect any changes to your protobuf definitions." <> line <>
    " *" <+> "DO NOT EDIT" <> line <>
    " */"

  private[java] val generatedCodeCommentString: String =
    s"""
       |/* This code was generated by Akka Serverless tooling.
       | * As long as this file exists it will not be re-generated.
       | * You are free to make changes to this file.
       | */""".stripMargin

  private[java] val managedCodeCommentString: String =
    s"""
       |/* This code is managed by Akka Serverless tooling.
       | * It will be re-generated to reflect any changes to your protobuf definitions.
       | * DO NOT EDIT
       | */""".stripMargin

  private[codegen] def generateImports(commands: Iterable[Command],
                                       state: Option[State],
                                       packageName: String,
                                       otherImports: Seq[String]): String = {
    val messageTypes = commands.toSeq
        .flatMap(command => Seq(command.inputType, command.outputType)) ++ state.map(_.fqn).toSeq

    val messageTypeImports = messageTypes
      .filterNot(_.parent.javaPackage == packageName)
      .map(typeImport)

    (messageTypeImports ++ otherImports).distinct.sorted
      .map(pkg => s"import $pkg;")
      .mkString("\n")
  }
}
