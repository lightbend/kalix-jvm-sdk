= Quickstart: Customer Registry with Views in Java

include::ROOT:partial$include.adoc[]
include::java:partial$attributes.adoc[]

Create a customer registry that includes queries in Java, package it into a container, and run it on Akka Serverless.

== In this Quickstart you will learn:

* How to add additional functionality, allowing customers to be queried by name and email.
* How to package the customer registry into a container.
* How to deploy and run the customer registry on Akka Serverless.

== Before you begin

* If you're new to Akka Serverless, {console}[create an account, window="console"] so you can try out Akka Serverless for free.
* You'll also need to install the https://developer.lightbend.com/docs/akka-serverless/akkasls/install-akkasls.html[Akka Serverless CLI, window="new-doc"] if you want to deploy from a terminal window.
* For this quickstart, you'll also need
** https://docs.docker.com/engine/install[Docker {minimum_docker_version} or higher, window="new"]
** Java {java-version} or higher
** https://maven.apache.org/download.cgi[Maven 3.x or higher, window="new"]
** https://github.com/fullstorydev/grpcurl#installation[`grpcurl`, window="new"]

[NOTE]
====
If you want to bypass writing code and jump straight to the deployment:

. Download the source code using the Akka Serverless CLI: 
`akkasls quickstart download customer-registry-views-java`

. Skip to <<Package and deploy your service>>.
====

== Start from the Customer Registry Entity

Start by downloading the  xref:java:quickstart/cr-value-entity-java.adoc[Customer Registry Quickstart] source code using the Akka Serverless CLI:

[source,command line]
----
akkasls quickstart download customer-registry-java
----

You can access the `Customer` https://developer.lightbend.com/docs/akka-serverless/reference/glossary.html#entity[Entity] with its https://developer.lightbend.com/docs/akka-serverless/reference/glossary.html#entity_key[Entity key]. In this guide we will describe how to retrieve customers by email or name instead.

== Define the CustomerByEmail View

. In your project, create a directory for your views protobuf files, `src/main/proto/customer/view`.
[.tabset]
Linux or macOS::
+
--
[source,command line]
----
mkdir -p ./src/main/proto/customer/view
----
--
Windows 10+::
+
--
[source,command line]
----
mkdir src/main/proto/customer/view
----
--

. Create a `customer_view.proto` file and save it in the `src/main/proto/customer/view` directory.

+
[source,proto,indent=0]
.src/main/proto/customer/view/customer_view.proto
----
include::example$java-customer-registry-views-quickstart/src/main/proto/customer/view/customer_view.proto[tag=declarations]
----
<1> The protobuf syntax version, `proto3`.
<2> The package name, `customer.view`.
<3> The Java outer classname, `CustomerViewModel`. Messages defined in this file will be generated as inner classes, for example `CustomerViewModel.ByEmailRequest`.
<4> Import the proto files for your domain model `customer/domain/customer_domain.proto` and Akka Serverless annotations `akkaserverless/annotations.proto`.

. Add the service endpoint
+
[source,proto,indent=0]
.src/main/proto/customer/view/customer_view.proto
----
include::example$java-customer-registry-views-quickstart/src/main/proto/customer/view/customer_view.proto[tag=CustomerByEmail]
----
<1> The Protobuf `service` for the View.
<2> The option that the Maven plugin will use to generate the `CustomerByEmail` View.
<3> The `UpdateCustomer` method defines how Akka Serverless will update the view.
<4> The source of the View is the `"customers"` Value Entity. This identifier is defined in the `entity_type: "customers"` property of the `(akkaserverless.file).value_entity` option in the `customer_domain.proto` file.
<5> The `(akkaserverless.method).view.update` annotation defines that this method is used for updating the View. You must define the `table` attribute for the table to be used in the query. Pick any name and use it in the query `SELECT` statement.
<6> The `GetCustomers` method defines the query to retrieve a customer by email.
<7> The `(akkaserverless.method).view.query` annotation defines that this method is used as a query of the View.
+
NOTE: In this sample we use the internal `domain.CustomerState` as the state of the view. This is convenient since it allows automatic updates of the view without any logic but has the draw back that it implicitly makes the `domain.CustomerState` type a part of the public service API. Transforming the state to another type than the incoming update will be illustrated in the `CustomerByName` example.

. Run `mvn compile` from the project root directory to generate source classes from the Protobuf definitions.
+
----
mvn compile
----
+
This will result in a compilation error in the `Main` class. That is expected because you added a new component. Fix the compilation error by adding `CustomerByEmailView::new` as the second parameter to `AkkaServerlessFactory.withComponents` in `src/main/java/customer/Main.java`.

[#deploy]
== Package and deploy your service

To compile, build the container image, and publish it to your container registry, follow these steps

. From the root project directory, compile the source code using Maven:
+
[source, command line]
----
mvn compile
----

. Use the `deploy` target to build the container image and publish it to your container registry. At the end of this command Maven will show you the container image URL you'll need in the next part of this quickstart.
+
[source, command line]
----
mvn deploy
----

. Sign in to your Akka Serverless account at: {console}
. If you do not have a project, click *Add Project* to create one, otherwise choose the project you want to deploy your service to.
. On the project dashboard click the "+" next to *services* to start the deployment wizard
. Choose a name for your service and click *Next*
. Enter the container image URL from the above step and click *Next*
. Click *Next* (no environment variables are needed for these samples)
. Check both _Add a route to this service_ and _Enable CORS_ and click *Next*
. Click *Finish* to start the deployment
. Click *Go to Service* to see your newly deployed service

[#invoke]
== Invoke your service

Now that you have deployed your service, the next step is to create a Customer using gRPCurl:

. From the "_Service Explorer_" click on the `Create` method in `CustomerService`
. Click on "_gRPCurl_"
. In the bottom section of the dialog, fill in the values you want to send to your service
. In the top section of the dialog, click the "_Copy to clipboard_" button
. Open a new command line and paste the content you just copied

Then you can try to find the Customer by email using gRPCurl as described above but with the `GetCustomer` method in `CustomerByEmail` instead.


== Define the CustomerByName View

. In the same `src/main/proto/customer/view/customer_view.proto` file add another View for finding customers by name.
+
Add the service endpoint
+
[source,proto,indent=0]
.src/main/proto/customer/view/customer_view.proto
----
include::example$java-customer-registry-views-quickstart/src/main/proto/customer/view/customer_view.proto[tag=CustomerByName]
----
<1> The `UpdateCustomer` method defines how Akka Serverless will update the view. In this case use a `CustomerViewState` that is different from the incoming `domain.CustomerState`.
<2> `transform_updates: true` defines that you want custom code in the `UpdateCustomer` method.
<3> The `GetCustomers` method defines the query to retrieve customers by name.

. Run `mvn compile` from the project root directory to generate source classes from the Protobuf definitions.
+
----
mvn compile
----
+
Again, this will result in a compilation error in the `Main` class. That is expected because you added a new component. Fix the compilation error by adding `CustomerByNameView::new` as the third parameter to `AkkaServerlessFactory.withComponents` in `src/main/java/customer/Main.java`.

== Implement UpdateCustomer

. Implement the `emptyState` and `updateCustomer` method in `CustomerByEmailView`:
+
[source, java, indent=0]
.src/main/java/customer/view/CustomerByEmailView.java
----
include::example$java-customer-registry-views-quickstart/src/main/java/customer/view/CustomerByNameView.java[tag=view]
----
<1> Empty state that will be used if no previous state has been stored for the View.
<2> From the incoming `CustomerDomain.CustomerState` that represents the change from the Value Entity create a `CustomerViewModel.CustomerViewState`.
<3> Return `effects().updateState` with the new state for the View.
+
NOTE: The state of the View is still per Entity. The `CustomerDomain.CustomerState customerState` parameter represents the changed state of a specific Value Entity. The `state` parameter is the existing state, if any, of the View for the Entity, i.e. the state that was previously returned via `effects().updateState`. If no previous state has been stored the `emptyState()` is used.

== Deploy the updated service

. Deploy the updated service by repeating the steps in <<deploy>>.

== Invoke the CustomerByName

. Similar to the steps in <<invoke>>
. Create several customers with same name
. Use the new `CustomerByName` instead of `CustomerByEmail` and then you should see multiple results from `CustomerByName/GetCustomers` for customers with the same name

== Next steps

* You can read more about Views in the xref:java:views.adoc[reference documentation].